{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MPCForces-Extractor","text":"<p>This tool extracts the forces from Altair Optistruct Runs from RBEs and it sums them up by connected parts autoamtically.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>When you have simple rigid elements for modelling bolts, the mpcforces can be written out to either .h3d or .mpcf file among other options. With these options there seems to be no easy way of getting the summed up forces per conneced part for every mpc elmeent. Below you can see an image with the mpc forses printed as a vector plot. In the image there are two connected parts. To manually get the desired force per part you have to go into hyperview, do a table export and sum them up. This also requires you to have sets or to manually select the nodes per part. For a multitude of mpc elements this process is a problem.</p> <p></p> <p>The desired process is this:</p> <p></p> <p>This tool is destined to solve this by automating it. The two major problems regarding this:</p> <ul> <li>Detect the connected parts with in an efficient way</li> <li>Read the mpcf File and assign each force to the mpc element (as this is not printed in the mpcf file)</li> </ul>"},{"location":"#functionality","title":"Functionality","text":"<p>This tool comes with different methods of using it</p>"},{"location":"#command-line-interface-cli","title":"Command Line Interface (CLI)","text":"<p>Recommended if you want to process a lot of files with small scripts and text output is enough.</p>"},{"location":"#app","title":"App","text":"<p>Recommended if you want to get to know the tool or if you want to explore previous run models again (= import database).</p>"},{"location":"#pure-python","title":"Pure Python","text":"<p>You also can use the tool directly. Exmaple is provided here.</p>"},{"location":"#basic-functionality-backend","title":"Basic Functionality (Backend)","text":"<p>The tool operates in the following way. CLI / App just shows the Input / Ouput.</p> <ul> <li>Detect RBE2 and RBE3 elements in your model</li> <li>Do a group segmentation for all connected (not by RBE2/RBE3) parts</li> <li>Ouput sums of forces per RBE Element and therefore showing you how much force is being transfereed by which RBE Element to which part</li> </ul> <p>where:</p> <ul> <li>Part: A element collection which are connected to each other (ignoring all RBE Elements). For the Hypermesh user: Its \"by attached\" but without considering RBE Elements</li> <li>RBE: Rigid Body Element. Currently RBE2 and RBE3 Elements are supported</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Thanks to Codie, because without him my python skills would not be nearly as mediocre as they are ;)</li> <li>Thank you dear Wulu Tea for keeping me running at night</li> </ul>"},{"location":"app/","title":"App","text":"<p>This is the first version to support a small frontend which is accessible from the browser and documented below.</p>"},{"location":"app/#run-the-frontend","title":"Run the Frontend","text":"<p>To start the app, please run the Taskfile (-&gt; quick-start) command</p> <pre><code>task app\n</code></pre> <p>this runs basically:</p> <pre><code>uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n</code></pre> <p>So, this starts a uvicorn server at your localhost which has a FastAPI instance (app).</p>"},{"location":"app/#pages","title":"Pages","text":"<p>The Server gives access to the following pages, which are very briefly documented here:</p>"},{"location":"app/#main-page","title":"Main Page","text":"<p>Allows for:</p> <ul> <li>Start the tool with custom files. Needed Files:<ul> <li>.fem File (Basically your Input Deck for Optistruct)</li> <li>.mpcf File (The forces on the RBE Slave Nodes). Its exported by Optistruct via the loadstep output request - mpcf: Format: Opti</li> </ul> </li> <li>Alternatively import a database (from a previous run) directly</li> </ul> <p>In both ways, the database will be filled and the following pages can be used.</p>"},{"location":"app/#mpc-page","title":"MPC Page","text":"<ul> <li>Shows the MPCs and their slave nodes (also separated by part)</li> <li>The copy buttons copy the node ids as a comma separated string into the clipboard. This can be then used e.g. in Hypermesh entity selector</li> <li>The summed up force per part is displayed</li> </ul>"},{"location":"app/#nodes-page","title":"Nodes Page","text":"<p>Sometimes the summed up force is not enough detail and oyu want to see the force distribution. This page can do this.</p> <p>In its default way:</p> <ul> <li>It displays all the nodes and their forces</li> <li>With the filter option you can use the node ids from the copy button from the MPC Page to quickly select the nodes you are interested in</li> </ul>"},{"location":"cli/","title":"CLI","text":""},{"location":"cli/#usage","title":"Usage","text":""},{"location":"cli/#command-mpcforces-extractor-extract","title":"Command: <code>mpcforces-extractor extract</code>","text":"<p>The main command is the <code>extract</code> command. This command will extract the mpc forces from the mpcf file and will output the summed up forces per connected part. The ouptput will be a text file with the summed up forces per connected part.</p> <p>Additionally the tcl code needed for visualizing the connected parts in HyperMesh will be generated. The tcl code will be saved in the same directory as the output file in the subfolder tcl-visualization.</p> <p>The command wants you to provide the path to the .fem model file as well as the path to the .mpcf file. Lastly, the output file path is needed. The blocksize is optional and is needed for reading the files. The default value is 8 (8 chars per field in line). For long ouptut it is recommended to increase the blocksize to 16 (not tested).</p>"},{"location":"cli/#command-mpcforces-extractor-visualize","title":"Command: <code>mpcforces-extractor visualize</code>","text":"<p>The command <code>visualize</code> visualizes the connected parts in HyperMesh. The command wants you to provide the path to the .fem model file as well as the path to the output directory. The tcl file is the output of the extract command. Know issue: If a compornent in the hypermesh model is named part1, part2, etc. the tcl script might not work as intended. This is due to the fact that the tcl script is using the part name to create the groups.</p>"},{"location":"cli/#source-code","title":"Source Code","text":""},{"location":"cli/#mpcforces_extractor.cli.extract.extract","title":"<code>extract</code>","text":"<p>Extracts the mpc forces and also writes the tcl lines for visualization</p> Source code in <code>mpcforces_extractor\\cli\\extract.py</code> <pre><code>@extractor_cmd.callback()\ndef extract(\n    input_path_fem: str = typer.Argument(..., help=\"Path to the .fem file (model)\"),\n    input_path_mpcf: str = typer.Argument(..., help=\"Path to the .mpcf file\"),\n    output_path: str = typer.Argument(..., help=\"Path to the output folder\"),\n    blocksize: int = typer.Option(8, help=\"Blocksize for the MPC forces\"),\n):\n    \"\"\"\n    Extracts the mpc forces and also writes the tcl lines for visualization\n    \"\"\"\n\n    # Check if the files exist, if not raise an error\n    if not Path(input_path_fem).exists():\n        raise FileNotFoundError(f\"File {input_path_fem} not found\")\n    if not Path(input_path_mpcf).exists():\n        raise FileNotFoundError(f\"File {input_path_mpcf} not found\")\n\n    # Extract the forces\n    mpc_force_extractor = MPCForceExtractor(\n        input_path_fem, input_path_mpcf, output_path\n    )\n    mpc_force_extractor.build_fem_and_subcase_data(blocksize)\n\n    # Write Summary\n    summary_writer = SummaryWriter(\n        mpc_force_extractor, mpc_force_extractor.output_folder\n    )\n    summary_writer.add_header()\n    summary_writer.add_mpc_lines()\n    summary_writer.write_lines()\n</code></pre>"},{"location":"cli/#mpcforces_extractor.cli.visualize.visualize","title":"<code>visualize</code>","text":"<p>Visualizes the connected parts of the model by moving them into separate components</p> Source code in <code>mpcforces_extractor\\cli\\visualize.py</code> <pre><code>@visualize_cmd.callback()\ndef visualize(\n    input_path_fem: str = typer.Argument(..., help=\"Path to the .fem file (model)\"),\n    output_path: str = typer.Argument(..., help=\"Path to the output folder\"),\n    blocksize: int = typer.Option(8, help=\"Blocksize for the MPC forces\"),\n):\n    \"\"\"\n    Visualizes the connected parts of the model by moving them into separate components\n    \"\"\"\n\n    # Check if the files exist, if not raise an error\n    if not Path(input_path_fem).exists():\n        raise FileNotFoundError(f\"File {input_path_fem} not found\")\n\n    # Visualize the connected parts\n    start_time = time.time()\n    output_vis = os.path.join(output_path, \"tcl_visualization\")\n\n    # Read the fem file\n    reader = FemFileReader(input_path_fem, blocksize)\n    reader.create_entities()\n\n    # Visualize\n    visualizer = VisualizerConnectedParts(output_vis)\n    visualizer.output_tcl_lines_for_part_vis()\n\n    print(\"TCL visualization lines written to\", output_vis)\n    print(\"..took \", round(time.time() - start_time, 2), \"seconds\")\n</code></pre>"},{"location":"quick_start/","title":"Quickstart","text":""},{"location":"quick_start/#installation","title":"Installation","text":"<p>To install this tool, you can simply use the pip install command like so:</p> <pre><code>pip install mpcforces-extractor\n</code></pre> <p>After installing it, you can access the cli tool via: <code>mpcforces-extractor</code> which will start the app.</p> <p>Alternatively you can use the command line interface tool (CLI)</p>"},{"location":"quick_start/#test-files","title":"Test Files","text":"<p>In order to make testing the tool easier, you can download the following files:</p> <p>m.fem</p> <p>m.mpcf</p>"},{"location":"quick_start/#taskfile","title":"Taskfile","text":"<p>The below described approach is for more development oriented people. If you are not interested in this, you can skip this section and use the CLI tool described above.</p> <p>The project has a Taskfile.yaml for your conveinience. Taskfile is an executeable file which you can download on: Taskfile and it makes your life easier.</p> <p>In the Taskfile you have commands available to start the program namely:</p> <pre><code>task run\n</code></pre> <p>which does the following:</p> <pre><code>poetry run python -m mpcforces_extractor.main\n</code></pre> <p>alternatively you can start the tool also with the <code>python -m</code>  command.</p> <p>If you want to run the program in the APP / Browser mode:</p> <pre><code>task app\n</code></pre> <p>which runs:</p> <pre><code>poetry run python -m mpcforces_extractor.app\n</code></pre> <p>which in turn stats the uvicorn server and let's you run it in your browser.</p>"},{"location":"source_code/","title":"Source Code (Pure Python)","text":"<p>Below you find an example script how to use it with pure python.</p>"},{"location":"source_code/#mpcforces_extractor.main.main","title":"<code>main()</code>","text":"<p>This is the main function that is used to test the MPCForceExtractor class Its there because of a entry point in the toml file</p> Source code in <code>mpcforces_extractor\\main.py</code> <pre><code>def main():\n    \"\"\"\n    This is the main function that is used to test the MPCForceExtractor class\n    Its there because of a entry point in the toml file\n    \"\"\"\n\n    input_folder = \"data/input\"\n    output_folder = \"data/output\"\n    model_name = \"m\"\n    # model_name = \"Flange\"\n    blocksize = 8\n\n    mpc_force_extractor = MPCForceExtractor(\n        input_folder + f\"/{model_name}.fem\",\n        input_folder + f\"/{model_name}.mpcf\",\n        output_folder + f\"/{model_name}\",\n    )\n\n    # Write Summary\n    mpc_force_extractor.build_fem_and_subcase_data(blocksize)\n    summary_writer = SummaryWriter(\n        mpc_force_extractor, mpc_force_extractor.output_folder\n    )\n    summary_writer.add_header()\n    summary_writer.add_mpc_lines()\n    summary_writer.write_lines()\n\n    # Visualize the connected parts\n    start_time = time.time()\n    output_vis = os.path.join(output_folder, model_name, \"tcl_visualization\")\n    visualizer = VisualizerConnectedParts(output_vis)\n    visualizer.output_tcl_lines_for_part_vis()\n\n    print(\"TCL visualization lines written to\", output_vis)\n    print(\"..took \", round(time.time() - start_time, 2), \"seconds\")\n</code></pre>"},{"location":"coverage/","title":"Dev-Coverage","text":""}]}